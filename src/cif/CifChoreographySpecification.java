package cif;

import base.*;

import java.io.*;
import java.util.*;

import base.Message;
import base.Peer;
import models.base.IllegalModelException;
import models.choreography.cif.CifModel;
import models.base.IllegalResourceException;
import models.choreography.cif.generated.*;

/**
 * Created by pascalpoizat on 05/02/2014.
 * translation in Java and refactoring of Python code by the VerChor team
 */
public class CifChoreographySpecification extends ChoreographySpecification {

    /**
     * LTS generation:
     * v = new Checker()
     * c = new Choreography(filename)
     * c.computeSyncSets(true)
     * c.generateLNT()
     * c.generateSVL(false,false)
     * v.cleanAll()
     * v.generateLTS(c,false)
     * <p/>
     * Synchronizability/Realizability:
     * v = new Checker()
     * c = new Choreograph(filename)
     * v.cleanSynchronizabilityResults() / v.cleanRealizabilityResults()
     * resultS = v.isSynchronizable(c,false) / resultR = v.isRealizable(c,false)
     * <p/>
     * ChoreographySpecification::computeSyncSets:
     * sets up the cone sets and synch sets of the states in this.stateMachine.states
     * <p/>
     * ChoreographySpecification::generateLNT:
     * creates an LNT file encoding the choreography specification (several processes)
     * <p/>
     * FILES
     * (given a choreography C, in a file C.cif)
     * <p/>
     * C.lnt: LNT file
     * C.svl: main SVL script (used to generate other files)
     * C_synchronizability.svl : SVL script to check for synchronizability. Generates C_synchronizability.bcg
     * C_realizability.svl : SVL script to check for realizability.
     * <p/>
     * generated by the main SVL script: (require C.lnt to work)
     * C_specification_min.bcg: reduction of the choreography specification LTS (SVL generated)
     * C_synch_composition.bcg: phase 1 reduction of the synchronous product of the projected peers (SVL generated)
     * C_synch_composition_min.bcg: phase 2 reduction of C_synch_composition.bcg (SVL generated)
     * C_asynch_composition.bcg: phase 1 reduction of the 1-bounded asynchronous product of the projected peers (SVL generated)
     * C_asynch_composition_min.bcg: phase 2 reduction of C_asynch_composition.bcg (SVL generated)
     * <p/>
     * generated by the verification scripts: (require the above SVL generated files to work)
     * C_synchronizability.bcg : counter example for synchronizability (SVL generated)
     * C_realizability.bcg : counter example for realizability (SVL generated)
     */


    public static final String NAME = "lnt based verification";
    public static final String VERSION = "1.0";

    // prefixes / suffixes for generated file contents
    private static final String synchronous_prefix = "synchro_";
    private static final String any_suffix = ":any";
    // file name parts
    private static final String synchronizability_suffix = "_synchronizability";
    private static final String realizability_suffix = "_realizability";
    private static final String minimizing_suffix = "_min";
    private static final String choreography_model_suffix = "_specification"; // was _bpmnlts
    private static final String asynchronous_composition_suffix = "_asynch_composition"; // was _acompo
    private static final String synchronous_composition_suffix = "_synch_composition"; // was _compo_sync
    // equivalences and reductions
    private static final String synchronizability_equivalence = "strong comparison using bfs";
    private static final String realizability_equivalence = "strong comparison using bfs";
    private static final String phase2_reduction_smart = "smart branching";
    private static final String phase2_reduction_no_smart = "root leaf branching";
    // commands
    private static final String EQUIVALENCE_CHECKER_COMMAND = "bisimulator";
    private static final String LTSGENERATION_COMMAND = "svl %s";
    private static final String SYNCHRONIZABILITYCHECK_COMMAND = "svl %s" + synchronizability_suffix;
    private static final String REALIZABILITYCHECK_COMMAND = "svl %s" + realizability_suffix;
    private static final String DEBUG_COMMAND = "bcg_info -labels %s";
    private static final String CLEAN_COMMAND = "svl -clean %s";
    // file suffixes
    private static final String svl_suffix = ".svl";
    private static final String lnt_suffix = ".lnt";
    private static final String bcg_suffix = ".bcg";

    // adapted
    private CifModel model;
    // own data
    private String name;
    private Behaviour behaviour;
    private HashMap<PeerId, Peer> peers;
    private HashMap<MessageId, Message> messages;

    // file related attributes
    private String userdir;
    private String choreography_model;
    private String synchronous_composition_model;
    private String asynchronous_composition_model;
    private String choreography_model_min;
    private String synchronous_composition_model_min;
    private String asynchronous_composition_model_min;
    private String synchronizability_result_model;
    private String realizability_result_model;
    private File realizability_script;
    private File synchronizability_script;
    private File general_script;
    private File lnt_file;

    public CifChoreographySpecification(CifModel model) throws IllegalModelException {
        super();
        this.model = model;
        setup();
    }

    private void setup() throws IllegalModelException {
        // builds the CifChoreographySpecification attributes from the model ones (to be used each time the model is changed)
        setupStrings();
        buildMessages();
        buildPeers();
        buildBehaviour();
    }

    @Override
    protected boolean conformsWith(HashMap<PeerId, Peer> peers) {
        return false; // NEXT RELEASE
        // issue : peers cannot be CIF models. May require "combination" factories eg CIF/LTS or PNML/PNML
    }

    @Override
    protected boolean isRealizable() {
        boolean rtr = false;
        try {
            generateFilesForRealizability(false, false); // generates LNT definitions, SVL general script and realizability checking SVL script
            executeCleanAll(); // removes previous version of scripts and files generated by them
            executeGenerateLts(); // computes BCG files
            rtr = executeRealizabilityCheck(); // checks for realizability
        } catch (Exception e) { // NEXT RELEASE deal with the different exceptions
            message(e.getMessage());
        }
        return rtr;
    }

    @Override
    protected boolean isSynchronizable() {
        boolean rtr = false;
        try {
            generateFilesForSynchronizability(false, false); // generates LNT definitions, SVL general script and realizability checking SVL script
            executeCleanAll(); // removes previous version of scripts and files generated by them
            executeGenerateLts(); // computes BCG files
            rtr = executeSynchronizabilityCheck(); // checks for synchronizability
        } catch (Exception e) { // NEXT RELEASE deal with the different exceptions
            message(e.getMessage());
        }
        return rtr;
    }

    @Override
    protected HashMap<PeerId, Peer> project() {
        return null; // NEXT RELEASE
    }

    private void generateFilesForRealizability(boolean withSmartReduction, boolean generatePeers) throws IllegalResourceException, IllegalModelException {
        generateLntFile();
        generateGeneralSvlScript(withSmartReduction, generatePeers);
        generateRealizabilitySvlScript();
    }

    private void generateFilesForSynchronizability(boolean withSmartReduction, boolean generatePeers) throws IllegalResourceException, IllegalModelException {
        generateLntFile();
        generateGeneralSvlScript(withSmartReduction, generatePeers);
        generateSynchronizabilitySvlScript();
    }

    private void setupStrings() {
        // sets up strings to be used in verification for the representation of different processes (synchronous composition, asynchronous composition, etc.)
        name = model.getResource().getName();
        name = name.substring(0, name.length() - (model.getSuffix().length() + 1));
        userdir = model.getResource().getParent();
        choreography_model = name + choreography_model_suffix + bcg_suffix;
        synchronous_composition_model = name + synchronous_composition_suffix + bcg_suffix;
        asynchronous_composition_model = name + asynchronous_composition_suffix + bcg_suffix;
        choreography_model_min = name + choreography_model_suffix + minimizing_suffix + bcg_suffix;
        synchronous_composition_model_min = name + synchronous_composition_suffix + minimizing_suffix + bcg_suffix;
        asynchronous_composition_model_min = name + asynchronous_composition_suffix + minimizing_suffix + bcg_suffix;
        synchronizability_result_model = name + synchronizability_suffix + bcg_suffix;
        realizability_result_model = name + realizability_suffix + bcg_suffix;
        lnt_file = new File(model.getResource().getParent(), name + lnt_suffix);
        general_script = new File(model.getResource().getParent(), name + svl_suffix);
        realizability_script = new File(model.getResource().getParent(), name + realizability_suffix + svl_suffix);
        synchronizability_script = new File(model.getResource().getParent(), name + synchronizability_suffix + svl_suffix);
        message("working directory: " + userdir);
        message("name: " + name);
    }

    private void generateLntFile() throws IllegalResourceException {
        // generate LNT file from a CIF model (definition of the MAIN process, ie the one for the choreography specification)
        String script = "";
        // TODO
        writeToFile(script, lnt_file);
        message("LNT file generated");
    }

    private void generateGeneralSvlScript(boolean withSmartReduction, boolean generatePeers) throws IllegalResourceException, IllegalModelException {
        // generate SVL file from a CIF model (definition of the annex processes generated from the MAIN one, ie the one for the choreography specification)
        String script = "";
        String reduction;
        // select the kind of reduction to be used
        if (withSmartReduction) {
            reduction = phase2_reduction_smart;
        } else {
            reduction = phase2_reduction_no_smart;
        }
        // header
        script += "% CAESAR_OPEN_OPTIONS=\"-silent -warning\"\n% CAESAR_OPTIONS=\"-more cat\"\n\n";
        script += "% DEFAULT_PROCESS_FILE=" + name + ".lnt\n\n";
        //
        script += String.format("\"%s\" = safety reduction of tau*.a reduction of branching reduction of \"MAIN [%s]\";\n\n", choreography_model_min, generateSvlAlphabet(behaviour.getAlphabet(), false, false, false));
        //
        script += String.format("\"%s\" = %s reduction of\n%s", synchronous_composition_model, reduction, generateSvlSyncRedCompositional(behaviour.getAlphabet(), peers));
        //
        script += String.format("\"%s\"= weak trace reduction of safety reduction of tau*.a reduction of branching reduction of \"%s\";\n\n", synchronous_composition_model_min, synchronous_composition_model);
        //
        script += String.format("\"%s\" = %s reduction of\n%s", asynchronous_composition_model, reduction, generateSvlAsyncRedCompositional(behaviour.getAlphabet(), peers, true));
        //
        script += String.format("\"%s\"= safety reduction of tau*.a reduction of branching reduction of \"%s\";\n\n", asynchronous_composition_model_min, asynchronous_composition_model);
        //
        if (generatePeers) {
            for (PeerId peer : peers.keySet()) {
                script += "\"" + name + "_peer_" + peer + ".bcg\" = safety reduction of tau*.a reduction of \"peer_" + peer + " [" + generateSvlAlphabet(behaviour.getAlphabet(), false, false, false) + "]\";\n\n";
                script += "\"" + name + "_apeer_" + peer + ".bcg\" = safety reduction of tau*.a reduction of \"apeer_" + peer + " [";
                script += generateSvlAlphabet(computeDirAlphabetforPeer(peer, computePeerAlphabetForPeer(peer, behaviour.getAlphabet())), false, false, false);
                script += "]\";\n\n";
            }
        }
        // TODO la suite

        writeToFile(script, general_script);
        message("general script generated");
    }

    private void generateSynchronizabilitySvlScript() throws IllegalResourceException {
        // generate SVL file from a CIF model for choregraphy verification (synchronizability check)
        // synchronizability check (WWW 2011) using trace equivalence between the synchronous composition and the 1-bounded asynchronous composition
        // important : the signalChange() method should be called each time the CIF model changes (synchronization issue)
        String script = String.format("\"%s\" = %s with %s \"%s\" ==  \"%s\";\n\n", synchronizability_result_model, synchronizability_equivalence, EQUIVALENCE_CHECKER_COMMAND, synchronous_composition_model, asynchronous_composition_model);
        message("synchronizability checked with: " + script);
        writeToFile(script, synchronizability_script);
    }

    private void generateRealizabilitySvlScript() throws IllegalResourceException {
        // generate SVL
        // equivalence between the choreography LTS and the distributed system LTS (async). Nb: here we only consider emissions in the distributed system
        // important : the signalChange() method should be called each time the CIF model changes (synchronization issue)
        String result_model = name + realizability_suffix + bcg_suffix;
        String script = String.format("\"%s\" = %s with %s \"%s\" ==  \"%s\";\n\n", realizability_result_model, realizability_equivalence, EQUIVALENCE_CHECKER_COMMAND, choreography_model, asynchronous_composition_model);
        message("realizability checked with: " + script);
        writeToFile(script, realizability_script);
    }

    private void writeToFile(String contents, File file) throws IllegalResourceException {
        // writes a content to a file
        try {
            FileWriter fw = new FileWriter(file);
            fw.write(contents);
            message("File " + file.getAbsolutePath() + " written");
            fw.close();
        } catch (IOException e) {
            IllegalResourceException e2 = new IllegalResourceException("Cannot open output resource");
            throw e2;
        }
    }

    private boolean executeRealizabilityCheck() throws ExecutionException {
        execute(String.format(REALIZABILITYCHECK_COMMAND, name));
        // check if a counter example has been generated
        File f = new File(realizability_result_model);
        if (f.exists()) {
            if (isVerbose()) {
                String debugInformation = execute(String.format(DEBUG_COMMAND, realizability_result_model));
                message(debugInformation);
            }
            return false;
        } else {
            return true;
        }
    }

    private boolean executeSynchronizabilityCheck() throws ExecutionException {
        execute(String.format(SYNCHRONIZABILITYCHECK_COMMAND, name));
        // check if a counter example has been generated
        File f = new File(synchronizability_result_model);
        if (f.exists()) {
            if (isVerbose()) {
                String debugInformation = execute(String.format(DEBUG_COMMAND, synchronizability_result_model));
                message(debugInformation);
            }
            return false;
        } else {
            return true;
        }
    }

    private void executeGenerateLts() throws ExecutionException {
        execute(String.format(LTSGENERATION_COMMAND, name));
    }

    private void executeCleanAll() throws ExecutionException {
        // removes all files generated by the SVL scripts
        execute(String.format(CLEAN_COMMAND, name));
        executeCleanSynchronizabilityResults();
        executeCleanRealizabiltiyResults();
    }

    private void executeCleanSynchronizabilityResults() throws ExecutionException {
        // removes files generated by the synchronizability check
        execute(String.format(CLEAN_COMMAND, name + synchronizability_suffix));
    }

    private void executeCleanRealizabiltiyResults() throws ExecutionException {
        // removes files generated by the realizability check
        execute(String.format(CLEAN_COMMAND, name + realizability_suffix));
    }

    private String execute(String command) throws ExecutionException {
        // helper to execute an external command and return the results
        String rtr, line;
        Process p;
        BufferedReader outputs;
        rtr = "";
        try {
            message("Executing ... " + command);
            p = Runtime.getRuntime().exec(command, null, new File(userdir));
            p.waitFor();
            outputs = new BufferedReader(new InputStreamReader(p.getInputStream()));
            while ((line = outputs.readLine()) != null) {
                rtr += line + "\n";
            }
        } catch (IOException e) {
            ExecutionException e2 = new ExecutionException("Error in executing command " + command);
            e2.setStackTrace(e.getStackTrace());
            error(e2.getMessage());
        } catch (InterruptedException e) {
            ExecutionException e2 = new ExecutionException("Error in executing command " + command);
            e2.setStackTrace(e.getStackTrace());
            error(e2.getMessage());
        }
        message(rtr);
        return rtr;

    }

    // computes behaviour adaptor
    private void buildBehaviour() {
        behaviour = new CifBehaviour(model, messages, peers);
    }

    // computes Peer adaptors
    private void buildPeers() throws IllegalModelException {
        CifPeer cifPeer;
        peers = new HashMap<PeerId, Peer>();
        for (models.choreography.cif.generated.Peer peer : model.getParticipants().getPeer()) {
            cifPeer = new CifPeer(peer);
            peers.put(cifPeer.getId(), cifPeer);
        }
    }

    // computes Message adaptors
    private void buildMessages() throws IllegalModelException {
        CifMessage cifMessage;
        messages = new HashMap<MessageId, Message>();
        for (Object o : model.getAlphabet().getMessageOrAction()) {
            if (o instanceof models.choreography.cif.generated.Message) {
                cifMessage = new CifMessage((models.choreography.cif.generated.Message) o);
                messages.put(cifMessage.getId(), cifMessage);
            }
        }
    }

    @Override
    public void about() {
        System.out.println(NAME + " " + VERSION);
    }

    // OLD

    private String computeSvlDefinitions(String name, Set<AlphabetElement> alphabet, Set<PeerId> peers, String reduction, boolean generatePeers) {
        String script = "";
        //
        return script;
    }

    // computes ...
    private Set<AlphabetElement> computeDirAlphabetforPeer(PeerId peer, Set<AlphabetElement> alphabet) {
        return new HashSet<AlphabetElement>(); //
    }

    // computes ...
    private Set<AlphabetElement> computePeerAlphabetForPeer(PeerId peer, Set<AlphabetElement> alphabet) {
        return new HashSet<AlphabetElement>(); //
    }

    // generates a string for an alphabet
    private String generateSvlAlphabet(Set<AlphabetElement> alphabet, boolean withAny, boolean startComma, boolean withSynchronizingMessage) {
        String rtr = "";
        int size = alphabet.size();
        int i = 0;
        Set<AlphabetElement> alphabetWork;
        if (!alphabet.isEmpty()) {
            if (withSynchronizingMessage) {
                SortedSet<AlphabetElement> sortedAlphabet = new TreeSet<AlphabetElement>(alphabet);
                alphabetWork = sortedAlphabet;
            } else {
                alphabetWork = alphabet;
            }
            if (startComma) {
                rtr += ",";
            }
            for (AlphabetElement alphabetElement : alphabetWork) {
                if (withSynchronizingMessage) {
                    rtr += synchronous_prefix;
                }
                rtr += alphabetElement.toString();
                if (withAny) {
                    rtr += any_suffix;
                }
                i++;
                if (i < size) {
                    rtr += ",";
                }
            }
        }
        return rtr;
    }

    // generates ...
    private String generateSvlSyncRedCompositional(Set<AlphabetElement> alphabet, HashMap<PeerId, Peer> peers) {
        return "* a sync red *"; // TODO
    }

    // generates ...
    private String generateSvlAsyncRedCompositional(Set<AlphabetElement> alphabet, HashMap<PeerId, Peer> peers, boolean withHiding) {
        return "* an async red *"; // TODO
    }


}
