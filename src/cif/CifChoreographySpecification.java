/**
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * verchor
 * Copyright (C) 2014 Pascal Poizat (@pascalpoizat)
 * emails: pascal.poizat@lip6.fr
 */

package cif;

import base.*;

import java.util.*;

import models.base.IllegalModelException;
import models.choreography.cif.CifModel;
import models.base.IllegalResourceException;

public class CifChoreographySpecification extends ChoreographySpecification {

    /**
     * LTS generation:
     * v = new Checker()
     * c = new Choreography(filename)
     * c.computeSyncSets(true)
     * c.generateLNT()
     * c.generateSVL(false,false)
     * v.cleanAll()
     * v.generateLTS(c,false)
     * <p>
     * Synchronizability/Realizability (supposes that LTS have been generated):
     * v = new Checker()
     * c = new Choreography(filename)
     * v.cleanSynchronizabilityResults() / v.cleanRealizabilityResults()
     * resultS = v.isSynchronizable(c,false) / resultR = v.isRealizable(c,false)
     * <p>
     * ChoreographySpecification::computeSyncSets:
     * sets up the cone sets and synch sets of the states in this.stateMachine.states
     * <p>
     * ChoreographySpecification::generateLNT:
     * creates an LNT file encoding the choreography specification (several processes)
     * <p>
     * FILES
     * (given a choreography C, in a file C.cif)
     * <p>
     * C.lnt: LNT file
     * C.svl: main SVL script (used to generate other files)
     * C_synchronizability.svl : SVL script to check for synchronizability. Generates C_synchronizability.bcg
     * C_realizability.svl : SVL script to check for realizability.
     * <p>
     * generated by the main SVL script: (require C.lnt to work)
     * C_specification_min.bcg: reduction of the choreography specification LTS (SVL generated)
     * C_synch_composition.bcg: phase 1 reduction of the synchronous product of the projected peers (SVL generated)
     * C_synch_composition_min.bcg: phase 2 reduction of C_synch_composition.bcg (SVL generated)
     * C_asynch_composition.bcg: phase 1 reduction of the 1-bounded asynchronous product of the projected peers (SVL generated)
     * C_asynch_composition_min.bcg: phase 2 reduction of C_asynch_composition.bcg (SVL generated)
     * <p>
     * generated by the verification scripts: (require the above SVL generated files to work)
     * C_synchronizability.bcg : counter example for synchronizability (SVL generated)
     * C_realizability.bcg : counter example for realizability (SVL generated)
     */

    public static final String NAME = "lnt based verification";
    public static final String VERSION = "1.0";

    // TODO refactor using refactoring_from_python.Choreography instead of models.choreography.cif.CifModel

    // adapted
    private CifModel model;
    // own data
    private Behaviour behaviour;
    private HashMap<PeerId, Peer> peers;
    private HashMap<MessageId, Message> messages;

    public CifChoreographySpecification(CifModel model) throws IllegalModelException, IllegalResourceException {
        super();
        this.model = model;
        setup();
    }

    private void setup() throws IllegalModelException, IllegalResourceException {
        // builds the CifChoreographySpecification attributes from the model ones (to be used each time the model is changed)
        // setupStrings();
        buildMessages();
        buildPeers();
        buildBehaviour();
    }

    @Override
    protected boolean conformsWith(HashMap<PeerId, Peer> peers) {
        return false; // ISSUE ENHANCEMENT implement conformance checking
        // issue : peers cannot be CIF models. May require "combination" factories eg CIF/LTS or PNML/PNML
    }

    @Override
    protected HashMap<PeerId, Peer> project() {
        return null; // ISSUE ENHANCEMENT implement projection
    }

    @Override
    protected boolean isRealizable() {
        return false; // TODO
    }

    @Override
    protected boolean isSynchronizable() {
        return false; // TODO
    }

    // computes behaviour adaptor
    private void buildBehaviour() {
        behaviour = new CifBehaviour(model, messages, peers);
    }

    // computes Peer adaptors
    private void buildPeers() throws IllegalModelException {
        CifPeer cifPeer;
        peers = new HashMap<>();
        for (models.choreography.cif.generated.Peer peer : model.getParticipants().getPeer()) {
            cifPeer = new CifPeer(peer);
            peers.put(cifPeer.getId(), cifPeer);
        }
    }

    // computes Message adaptors
    private void buildMessages() throws IllegalModelException {
        CifMessageAdaptor cifMessage;
        messages = new HashMap<>();
        for (Object o : model.getAlphabet().getMessageOrAction()) {
            if (o instanceof models.choreography.cif.generated.Message) {
                cifMessage = new CifMessageAdaptor((models.choreography.cif.generated.Message) o);
                messages.put(cifMessage.getId(), cifMessage);
            }
        }
    }

    @Override
    public void about() {
        System.out.println(NAME + " " + VERSION);
    }


}
