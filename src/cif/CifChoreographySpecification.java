package cif;

import base.*;

import java.io.*;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

import models.choreography.cif.CifModel;
import models.base.IllegalResourceException;
import sun.org.mozilla.javascript.internal.EcmaError;

/**
 * Created by pascalpoizat on 05/02/2014.
 * translation in Java and refactoring of Python code by the VerChor team
 */
public class CifChoreographySpecification extends ChoreographySpecification {

    /**
     * LTS generation:
     * v = new Checker()
     * c = new Choreography(filename)
     * c.computeSyncSets()
     * c.generateLNT()
     * c.generateSVL(false,false)
     * v.cleanUp()
     * v.generateLTS(c,false)
     *
     * Synchronizability/Realizability:
     * v = new Checker()
     * c = new Choreograph(filename)
     * v.cleanResults()
     * resultS = v.isSynchronizable(c,false)
     * resultR = v.isRealizable(c,false)
     *
     * ChoreographySpecification::computeSyncSets:
     * sets up the cone sets and synch sets of the states in this.stateMachine.states
     *
     * ChoreographySpecification::generateLNT:
     * creates an LNT file encoding the choreography specification (several processes)
     *
     * FILES
     * (given a choreography C, in a file C.cif)
     *
     * C.lnt: LNT file
     * C.svl: main SVL script (used to generate other files)
     * C_synchronizability.svl : SVL script to check for synchronizability. Generates C_synchronizability.bcg
     * C_realizability.svl : SVL script to check for realizability.
     *
     * generated by the main SVL script: (require C.lnt to work)
     * C_specification_min.bcg: reduction of the choreography specification LTS (SVL generated)
     * C_synch_composition_min1.bcg: phase 1 reduction of the synchronous product of the projected peers (SVL generated)
     * C_synch_composition_min2.bcg: phase 2 reduction of C_synch_composition_min1.bcg (SVL generated)
     * C_asynch_composition_min1.bcg: phase 1 reduction of the 1-bounded asynchronous product of the projected peers (SVL generated)
     * C_asynch_composition_min2.bcg: phase 2 reduction of C_asynch_composition_min2.bcg (SVL generated)
     *
     * generated by the verification scripts: (require the above SVL generated files to work)
     * C_synchronizability.bcg : counter example for synchronizability (SVL generated)
     * C_realizability.bcg : counter example for realizability (SVL generated)
     */


    public static final String NAME = "lnt based verification";
    public static final String VERSION = "1.0";

    // file name parts
    private static final String synchronizability_suffix = "_synchronizability";
    private static final String realizability_suffix = "_realizability";
    private static final String minimizing_suffix = "_min";
    private static final String choreography_model_suffix = "_specification"; // was _bpmnlts
    private static final String asynchronous_composition_suffix = "_asynch_composition"; // was _acompo
    private static final String synchronous_composition_suffix = "_synch_composition"; // was _compo_sync
    // equivalences and reductions
    private static final String synchronizability_equivalence = "strong comparison using bfs";
    private static final String realizability_equivalence = "strong comparison using bfs";
    private static final String phase1_reduction[] = {"branching","tau*a","safety"}; // in the order of application
    private static final String phase2_reduction_smart = "smart branching";
    private static final String phase2_reduction_no_smart = "root leaf branching";
    // commands
    private static final String EQUIVALENCE_CHECKER_COMMAND = "bisimulator";
    private static final String LTSGENERATION_COMMAND = "svl %s";
    private static final String SYNCHRONIZABILITYCHECK_COMMAND = "svl %s" + synchronizability_suffix;
    private static final String REALIZABILITYCHECK_COMMAND = "svl %s" + realizability_suffix;
    private static final String DEBUG_COMMAND = "bcg_info -labels %s";
    private static final String CLEAN_COMMAND = "svl -clean %s";
    // file suffixes
    private static final String svl_suffix = ".svl";
    private static final String lnt_suffix = ".lnt";
    private static final String bcg_suffix = ".bcg";

    // NOTE: some of the elements in this class are to be moved in order to promote separation between LNT-based specific code (in Cif* or Cif*WithLnt classes) wrt generic code (in ChoreographyVerificationEngine)

    private CifModel model;
    private String name;
    private String choreography_model;
    private String synchronous_composition_model;
    private String asynchronous_composition_model;
    private String synchronizability_result_model;
    private String realizability_result_model;
    private File realizability_script;
    private File synchronizability_script;

    public CifChoreographySpecification(CifModel model) {
        super();
        this.model = model;
        setupStrings();
    }

    @Override
    protected boolean conformsWith(HashMap<PeerId, Peer> peers) {
        return false; // TODO (issue : peers cannot be CIF models. May require "combination" factories eg CIF/LTS or PNML/PNML)
    }

    @Override
    protected boolean isRealizable() {
        boolean rtr = false;
        try {
            // if the model has changed, we have to regenerate LNT, SVL, and BCG files
            if (hasChanged()) {
                executeCleanUp(); // removes previous version of scripts and files generated by them
                generateFilesForRealizability(); // generates LNT definitions, SVL general script and realizability checking SVL script
                executeGenerateLts(); // computes BCG files
            }
            rtr = executeRealizabilityCheck(); // checks for realizability
        } catch (IllegalResourceException e) {
            error(e.getMessage());
        } catch (ExecutionException e) {
            error(e.getMessage());
        }
        return rtr;
    }

    @Override
    protected boolean isSynchronizable() {
        boolean rtr = false;
        try {
            // if the model has changed, we have to regenerate LNT, SVL, and BCG files
            if (hasChanged()) {
                executeCleanUp(); // removes previous version of scripts and files generated by them
                generateFilesForSynchronizability(); // generates LNT definitions, SVL general script and realizability checking SVL script
                executeGenerateLts(); // computes BCG files
            }
            rtr = executeSynchronizabilityCheck(); // checks for synchronizability
        } catch (IllegalResourceException e) {
            error(e.getMessage());
        } catch (ExecutionException e) {
            error(e.getMessage());
        }
        return rtr;
    }

    @Override
    protected HashMap<PeerId, Peer> project() {
        return null; // TODO
    }

    private void generateFilesForRealizability() throws IllegalResourceException {
        setupStrings();
        generateLntFile();
        generateGeneralSvlScript();
        generateRealizabilitySvlScript();
        setChanged(false);
    }

    private void generateFilesForSynchronizability() throws IllegalResourceException {
        setupStrings();
        generateLntFile();
        generateGeneralSvlScript();
        generateSynchronizabilitySvlScript();
        setChanged(false);
    }

    private void setupStrings() {
        // sets up strings to be used in verification for the representation of different processes (synchronous composition, asynchronous composition, etc.)
        name = model.getResource().getName();
        name = name.substring(0, name.length() - (model.getSuffix().length() + 1));
        choreography_model = name + choreography_model_suffix + minimizing_suffix + bcg_suffix;
        synchronous_composition_model = name + synchronous_composition_suffix + minimizing_suffix + bcg_suffix;
        asynchronous_composition_model = name + asynchronous_composition_suffix + minimizing_suffix + bcg_suffix;
        synchronizability_result_model = name + synchronizability_suffix + bcg_suffix;
        realizability_result_model = name + realizability_suffix + bcg_suffix;
        realizability_script = new File(model.getResource().getParent(), name + realizability_suffix + svl_suffix);
        synchronizability_script = new File(model.getResource().getParent(), name + synchronizability_suffix + svl_suffix);
        message("name: " + name);
        message("synchronizability script: " + synchronizability_script.getAbsolutePath());
        message("realizability script: " + realizability_script.getAbsolutePath());
    }

    private void generateLntFile() {
        // TODO
    }

    private void generateGeneralSvlScript() {
        // TODO
    }

    private void generateSynchronizabilitySvlScript() throws IllegalResourceException {
        // generate SVL file from a CIF model for choregraphy verification (synchronizability check)
        // synchronizability check (WWW 2011) using trace equivalence between the synchronous composition and the 1-bounded asynchronous composition
        // important : the signalChange() method should be called each time the CIF model changes (synchronization issue)
        String script = String.format("\"%s\" = %s with %s \"%s\" ==  \"%s\";\n\n", synchronizability_result_model, synchronizability_equivalence, EQUIVALENCE_CHECKER_COMMAND, synchronous_composition_model, asynchronous_composition_model);
        message("synchronizability checked with: " + script);
        writeToFile(script, synchronizability_script);
    }

    private void generateRealizabilitySvlScript() throws IllegalResourceException {
        // generate SVL
        // equivalence between the choreography LTS and the distributed system LTS (async). Nb: here we only consider emissions in the distributed system
        // important : the signalChange() method should be called each time the CIF model changes (synchronization issue)
        String result_model = name + realizability_suffix + bcg_suffix;
        String script = String.format("\"%s\" = %s with %s \"%s\" ==  \"%s\";\n\n", realizability_result_model, realizability_equivalence, EQUIVALENCE_CHECKER_COMMAND, choreography_model, asynchronous_composition_model);
        message("realizability checked with: " + script);
        writeToFile(script, realizability_script);
    }

    private void writeToFile(String contents, File file) throws IllegalResourceException {
        // writes a content to a file
        try {
            FileWriter fw = new FileWriter(file);
            fw.write(contents);
            message("File " + file.getAbsolutePath() + " written");
            fw.close();
        } catch (IOException e) {
            IllegalResourceException e2 = new IllegalResourceException("Cannot open output resource");
            throw e2;
        }
    }

    private boolean executeRealizabilityCheck() throws ExecutionException {
        execute(String.format(REALIZABILITYCHECK_COMMAND, name));
        // check if a counter example has been generated
        File f = new File(realizability_result_model);
        if (f.exists()) {
            if (isVerbose()) {
                String debugInformation = execute(String.format(DEBUG_COMMAND, realizability_result_model));
                message(debugInformation);
            }
            return false;
        } else {
            return true;
        }
    }

    private boolean executeSynchronizabilityCheck() throws ExecutionException {
        execute(String.format(SYNCHRONIZABILITYCHECK_COMMAND, name));
        // check if a counter example has been generated
        File f = new File(synchronizability_result_model);
        if (f.exists()) {
            if (isVerbose()) {
                String debugInformation = execute(String.format(DEBUG_COMMAND, synchronizability_result_model));
                message(debugInformation);
            }
            return false;
        } else {
            return true;
        }
    }

    private void executeGenerateLts() throws ExecutionException {
        execute(String.format(LTSGENERATION_COMMAND, name));
    }

    private void executeCleanUp() throws ExecutionException {
        execute(String.format(CLEAN_COMMAND, name));
        execute(String.format(CLEAN_COMMAND, name + synchronizability_suffix));
        execute(String.format(CLEAN_COMMAND, name + realizability_suffix));
    }

    private String execute(String command) throws ExecutionException {
        // helper to execute an external command and return the results
        String rtr, line;
        Process p;
        BufferedReader outputs;
        rtr = "";
        try {
            message("Executing ... " + command);
            p = Runtime.getRuntime().exec(command);
            p.waitFor();
            outputs = new BufferedReader(new InputStreamReader(p.getInputStream()));
            while ((line = outputs.readLine()) != null) {
                rtr += line + "\n";
            }
        } catch (IOException e) {
            ExecutionException e2 = new ExecutionException("Error in executing command " + command);
            e2.setStackTrace(e.getStackTrace());
            error(e2.getMessage());
        } catch (InterruptedException e) {
            ExecutionException e2 = new ExecutionException("Error in executing command " + command);
            e2.setStackTrace(e.getStackTrace());
            error(e2.getMessage());
        }
        return rtr;

    }

    @Override
    public void about() {
        System.out.println(NAME + " " + VERSION);
    }

    // OLD

    private String computeSvlDefinitions(String name, List<String> alphabet, List<String> peers, String reduction, boolean generatePeers) {
        String script = "";
        //
        script += "% CAESAR_OPEN_OPTIONS=\"-silent -warning\"\n% CAESAR_OPTIONS=\"-more cat\"\n\n";
        script += "% DEFAULT_PROCESS_FILE=" + name + ".lnt\n\n";
        //
        script += "\"" + name + "_bpmnlts_min.bcg\" = safety reduction of tau*.a reduction of branching reduction of \"MAIN [" + generateSvlAlphabet(alphabet, false, false) + "]\";\n\n";
        //
        script += "\"" + name + "_compo_sync.bcg\" = " + reduction + " reduction of\n" + generateSvlSyncRedCompositional(alphabet, peers);
        //
        script += "\"" + name + "_compo_sync_min.bcg\"= weak trace reduction of safety reduction of tau*.a reduction of branching reduction of \"" + name + "_compo_sync.bcg\";\n\n";
        //
        script += "\"" + name + "_acompo.bcg\" = " + reduction + " reduction of\n" + generateSvlAsyncRedCompositional(alphabet, peers, true);
        //
        script += "\"" + name + "_acompo_min.bcg\"= safety reduction of tau*.a reduction of branching reduction of \"" + name + "_acompo.bcg\";\n\n";
        //
        if (generatePeers) {
            for (String peer : peers) {
                script += "\"" + name + "_peer_" + peer + ".bcg\" = safety reduction of tau*.a reduction of \"peer_" + peer + " [" + generateSvlAlphabet(alphabet, false, false) + "]\";\n\n";
                script += "\"" + name + "_apeer_" + peer + ".bcg\" = safety reduction of tau*.a reduction of \"apeer_" + peer + " [";
                script += generateSvlAlphabet(computeDirAlphabetforPeer(peer, computePeerAlphabetForPeer(peer, alphabet)), false, false);
                script += "]\";\n\n";
            }
        }
        //
        return script;
    }

    // computes ...
    private List<String> computeDirAlphabetforPeer(String peer, List<String> alphabet) {
        return new ArrayList<String>(); //
    }

    // computes ...
    private List<String> computePeerAlphabetForPeer(String peer, List<String> alphabet) {
        return new ArrayList<String>(); //
    }

    // computes the alphabet of a choreography
    private List<String> computeAlphabet() {
        return new ArrayList<String>(); //
    }

    // computes the list of peers of a choreography
    private List<String> computePeers() {
        return new ArrayList<String>(); //
    }

    // generates a string for an alphabet
    private String generateSvlAlphabet(List<String> alphabet, boolean withAny, boolean withSynchronizingMessage) {
        return "* the alphabet *"; //
    }

    // generates ...
    private String generateSvlSyncRedCompositional(List<String> alphabet, List<String> peers) {
        return "* a sync red *"; //
    }    // generates ...

    private String generateSvlAsyncRedCompositional(List<String> alphabet, List<String> peers, boolean withHiding) {
        return "* an async red *"; //
    }


}
